// Copyright (c) Zefchain Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! Conversions from types generated by [`wit-bindgen`] to types declared in [`linera-sdk`].

use std::collections::BTreeSet;
use linera_base::{
    crypto::CryptoHash,
    data_types::{Amount, BlockHeight, StreamUpdate},
    identifiers::{
        AccountOwner, ApplicationId, ChainId, GenericApplicationId, MessageId, ModuleId, StreamId,
        StreamName,
    },
    ownership::{ChangeApplicationPermissionsError, CloseChainError},
    vm::VmRuntime,
};
use linera_execution::ResourceControlPolicy;
use super::wit::{
    contract_runtime_api as wit_contract_api,
    exports::linera::app::contract_entrypoints as wit_entrypoints,
};

impl From<wit_contract_api::CryptoHash> for CryptoHash {
    fn from(crypto_hash: wit_contract_api::CryptoHash) -> Self {
        CryptoHash::from([
            crypto_hash.part1,
            crypto_hash.part2,
            crypto_hash.part3,
            crypto_hash.part4,
        ])
    }
}

impl From<wit_contract_api::Array20> for [u8; 20] {
    fn from(ethereum_address: wit_contract_api::Array20) -> Self {
        let mut bytes = [0u8; 20];
        bytes[0..8].copy_from_slice(&ethereum_address.part1.to_le_bytes());
        bytes[8..16].copy_from_slice(&ethereum_address.part2.to_le_bytes());
        bytes[16..20].copy_from_slice(&ethereum_address.part3.to_le_bytes());
        bytes
    }
}

impl From<wit_contract_api::AccountOwner> for AccountOwner {
    fn from(account_owner: wit_contract_api::AccountOwner) -> Self {
        match account_owner {
            wit_contract_api::AccountOwner::Reserved(value) => AccountOwner::Reserved(value),
            wit_contract_api::AccountOwner::Address32(value) => {
                AccountOwner::Address32(value.into())
            }
            wit_contract_api::AccountOwner::Address20(value) => {
                AccountOwner::Address20(value.into())
            }
        }
    }
}

impl From<wit_contract_api::ModuleId> for ModuleId {
    fn from(module_id: wit_contract_api::ModuleId) -> Self {
        ModuleId::new(
            module_id.contract_blob_hash.into(),
            module_id.service_blob_hash.into(),
            module_id.vm_runtime.into(),
        )
    }
}

impl From<wit_contract_api::VmRuntime> for VmRuntime {
    fn from(vm_runtime: wit_contract_api::VmRuntime) -> Self {
        match vm_runtime {
            wit_contract_api::VmRuntime::Wasm => VmRuntime::Wasm,
            wit_contract_api::VmRuntime::Evm => VmRuntime::Evm,
        }
    }
}

impl From<wit_contract_api::MessageId> for MessageId {
    fn from(message_id: wit_contract_api::MessageId) -> Self {
        MessageId {
            chain_id: message_id.chain_id.into(),
            height: BlockHeight(message_id.height.inner0),
            index: message_id.index,
        }
    }
}

impl From<wit_contract_api::ApplicationId> for ApplicationId {
    fn from(application_id: wit_contract_api::ApplicationId) -> Self {
        ApplicationId::new(application_id.application_description_hash.into())
    }
}

impl From<wit_contract_api::ChainId> for ChainId {
    fn from(chain_id: wit_contract_api::ChainId) -> Self {
        ChainId(chain_id.inner0.into())
    }
}

impl From<wit_contract_api::Amount> for Amount {
    fn from(balance: wit_contract_api::Amount) -> Self {
        let (lower_half, upper_half) = balance.inner0;
        let value = ((upper_half as u128) << 64) | (lower_half as u128);
        Amount::from_attos(value)
    }
}

impl From<wit_contract_api::CloseChainError> for CloseChainError {
    fn from(guest: wit_contract_api::CloseChainError) -> Self {
        match guest {
            wit_contract_api::CloseChainError::NotPermitted => CloseChainError::NotPermitted,
        }
    }
}

impl From<wit_contract_api::ChangeApplicationPermissionsError>
    for ChangeApplicationPermissionsError
{
    fn from(guest: wit_contract_api::ChangeApplicationPermissionsError) -> Self {
        match guest {
            wit_contract_api::ChangeApplicationPermissionsError::NotPermitted => {
                ChangeApplicationPermissionsError::NotPermitted
            }
        }
    }
}

impl From<wit_entrypoints::CryptoHash> for CryptoHash {
    fn from(crypto_hash: wit_entrypoints::CryptoHash) -> Self {
        CryptoHash::from([
            crypto_hash.part1,
            crypto_hash.part2,
            crypto_hash.part3,
            crypto_hash.part4,
        ])
    }
}

impl From<wit_entrypoints::ApplicationId> for ApplicationId {
    fn from(application_id: wit_entrypoints::ApplicationId) -> Self {
        ApplicationId::new(application_id.application_description_hash.into())
    }
}

impl From<wit_entrypoints::GenericApplicationId> for GenericApplicationId {
    fn from(generic_application_id: wit_entrypoints::GenericApplicationId) -> Self {
        match generic_application_id {
            wit_entrypoints::GenericApplicationId::System => GenericApplicationId::System,
            wit_entrypoints::GenericApplicationId::User(application_id) => {
                GenericApplicationId::User(application_id.into())
            }
        }
    }
}

impl From<wit_entrypoints::ChainId> for ChainId {
    fn from(chain_id: wit_entrypoints::ChainId) -> Self {
        ChainId(chain_id.inner0.into())
    }
}

impl From<wit_contract_api::ResourceControlPolicy> for ResourceControlPolicy {
    fn from(guest: wit_contract_api::ResourceControlPolicy) -> ResourceControlPolicy {
        let wit_contract_api::ResourceControlPolicy {
            block,
            fuel_unit,
            read_operation,
            write_operation,
            byte_read,
            byte_written,
            blob_read,
            blob_published,
            blob_byte_read,
            blob_byte_published,
            byte_stored,
            operation,
            operation_byte,
            message,
            message_byte,
            service_as_oracle_query,
            http_request,
            maximum_fuel_per_block,
            maximum_service_oracle_execution_ms,
            maximum_block_size,
            maximum_bytecode_size,
            maximum_blob_size,
            maximum_published_blobs,
            maximum_block_proposal_size,
            maximum_bytes_read_per_block,
            maximum_bytes_written_per_block,
            maximum_oracle_response_bytes,
            maximum_http_response_bytes,
            http_request_timeout_ms,
            http_request_allow_list,
        } = guest;
        ResourceControlPolicy {
            block: block.into(),
            fuel_unit: fuel_unit.into(),
            read_operation: read_operation.into(),
            write_operation: write_operation.into(),
            byte_read: byte_read.into(),
            byte_written: byte_written.into(),
            blob_read: blob_read.into(),
            blob_published: blob_published.into(),
            blob_byte_read: blob_byte_read.into(),
            blob_byte_published: blob_byte_published.into(),
            byte_stored: byte_stored.into(),
            operation: operation.into(),
            operation_byte: operation_byte.into(),
            message: message.into(),
            message_byte: message_byte.into(),
            service_as_oracle_query: service_as_oracle_query.into(),
            http_request: http_request.into(),
            maximum_fuel_per_block,
            maximum_service_oracle_execution_ms,
            maximum_block_size,
            maximum_bytecode_size,
            maximum_blob_size,
            maximum_published_blobs,
            maximum_block_proposal_size,
            maximum_bytes_read_per_block,
            maximum_bytes_written_per_block,
            maximum_oracle_response_bytes,
            maximum_http_response_bytes,
            http_request_timeout_ms,
            http_request_allow_list: http_request_allow_list.into_iter().collect::<BTreeSet<_>>(),
        }
    }
}


impl From<wit_entrypoints::StreamName> for StreamName {
    fn from(stream_name: wit_entrypoints::StreamName) -> Self {
        StreamName(stream_name.inner0)
    }
}

impl From<wit_entrypoints::StreamId> for StreamId {
    fn from(stream_id: wit_entrypoints::StreamId) -> Self {
        StreamId {
            application_id: stream_id.application_id.into(),
            stream_name: stream_id.stream_name.into(),
        }
    }
}

impl From<wit_entrypoints::StreamUpdate> for StreamUpdate {
    fn from(stream_update: wit_entrypoints::StreamUpdate) -> Self {
        StreamUpdate {
            chain_id: stream_update.chain_id.into(),
            stream_id: stream_update.stream_id.into(),
            previous_index: stream_update.previous_index,
            next_index: stream_update.next_index,
        }
    }
}
